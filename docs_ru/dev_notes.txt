++++++++++++++++++++
Заметки разработчиков
++++++++++++++++++++

===========
СХЕМА ФАЙЛОВ
===========

# используется практически всем (и считается блоком!)
win32defines.py
win32functions.py
win32structures.py

# Поиск окон и их атрибутов
findwindows.py
handleprops.py

# обертки окон, получение дополнительной информацию для конкретных элементов управления
# задать понятное имя класса 
controls\common_controls.py
controls\controlactions.py
controls\hwndwrapper.py
controls\win32_controls.py

# в настоящее время зависит от имени класса Friendly 
# вероятно, необходимо изменить его структуру, чтобы он не зависел от элементов управления!
# может быть, переместить этот материал в _application_?
findbestmatch.py  # на данный момент зависит от controls!


controlactions.py

tests\allcontrols.py
tests\asianhotkey.py
tests\comboboxdroppedheight.py
tests\comparetoreffont.py
tests\leadtrailspaces.py
tests\miscvalues.py
tests\missalignment.py
tests\missingextrastring.py
tests\overlapping.py
tests\repeatedhotkey.py
tests\translation.py
tests\truncation.py


controlproperties.py

xml_helpers.py

	FindDialog.py
	PyDlgCheckerWrapper.py

application.py
test_application.py


====================
Best matching
====================
difflib предоставляет эту поддержку
Для меню это просто сопоставляем с текстом пункта меню.
Для элементов управления история сложнее, потому что хотелось бы сравнить со следующим:

   - Текст управления, если он существует
   - Понятное имя класса 
   - Контрольный текст + Понятное имя класса (если существует текст элемента управления)
   - (Возможно) ближайший static + FriendlyClassName
   
например
	FindWhatCombo, ComboBox1,
или же
 	Text, TextRiadio, RadioButton2

1) сам элемент управления знает, на что он должен ссылаться
2) Необходимо устранить неоднозначность по всем элементам управления в диалоге
3) тогда мы должны соответствовать
	


====================
ATTRIBUTE RESOLUTION
====================
Снова задумался...
app.dlg.control




ДВА УРОВНЯ 
 * application.member (Python resolves)
 	атрибут объекта приложения
 * application.dialog
 	ссылка на диалог

ТРИ УРОВНЯ
 * application.member.attr (Python resolves)
 	другой атрибут предыдущего элемента
 * application.dialog.member
 	член объекта диалогового окна
 * application.dialog.control
	элемент управления в диалоговом окне

ЧЕТЫРЕ УРОВНЯ (leaving out Python resolved)
 * application.dialog.member.member
 * application.dialog.control.member
 
 
ЗАДЕРЖКА РАЗРЕШЕНИЯ НА УСПЕХ
Возьмем пример ::

	app.dlg.control.action()

Если мы оставим синтаксические и программные ошибки, есть еще ряд причин, по которым он может потерпеть неудачу.

dlg может не быть найден
возможно, control не найден
либо dlg или control могут быть отключены

диалоговое окно и элемент управления могут быть найдены, но в неправильном диалоговом окне (например, в Notepad вы можете вызвать 2 диалоговых окна "Page Setup", оба с помощью кнопки OK)

Одним из решений было бы просто добавить "sleep" перед попыткой найти каждый новый диалог (чтобы убедиться, что он там и готов), но это будет означать много ненужных ожиданий.

Итак, решение, которое я попробовал:
 - выполнить полное разрешение доступа к атрибуту в самое позднее время
 - если это не удается, подождать и попробовать снова
 - после указанного тайм-аута сбой поднимает исходное исключение.
 
Это означает, что в обычном случае у вас нет ненужных ожиданий - а в случае сбоя - вы все равно получаете исключение с ошибкой.

Также ожидание разрешения как можно позже останавливает ошибки, когда более ранняя часть пути завершается успешно, но находит неправильный элемент.

Так, например, если находит диалоговое окно настройки страницы в блокноте
# откройте диалоговое окно настройки принтера (которое имеет заголовок "Page Setup")
app.PageSetup.Printer.Click()

# если это выполняется слишком быстро, он фактически находит текущий диалог настройки страницы
# до того, как откроется следующий диалог, но этот диалог не имеет свойств
# кнопка - так возникает ошибка.
# поскольку мы повторно запускаем разрешение с самого начала, мы находим новый диалог pagesetup.
app.PageSetup.Properties.Click()



==================
WRITING TO DIALOGS
==================
Нам нужен способ убедиться, что диалог активен без доступа к элементу управления на нем.
например ::

  app.MainWin.MenuSelect("Something That->Loads a Dialog")
  app.Dlg._write("dlg.xml")

или более сложная проблема::

	app.PageSetup.Printer.Click()
	app.PageSetup._write("pagesetup.xml") 

В этом втором примере очень трудно быть уверенным, что отображается правильный диалог Page Setup.

Единственный способ быть действительно уверенным-проверить наличие определенных элементов управления (ID, Class, text, whatever) - но было бы неплохо не иметь дело с ними :-(

Еще один менее декларативный (больше магии?) заключается в сканировании списка доступных windows/controls, и если они не изменились, то считаем, что отображается правильный.

При тестировании и наличии XML-файлов мы должны использовать их, чтобы убедиться, что у нас есть правильный диалог (с помощью Class/ID)










  


